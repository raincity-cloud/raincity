// Auto-generated by smithy-gen. Do not edit.
import { z } from "zod/v4";

export const bodySchema = z.instanceof(Uint8Array);
export const streamingBlobSchema = z.instanceof(Uint8Array);
export const accessPointAliasSchema = z.boolean();
export const allowQuotedRecordDelimiterSchema = z.boolean();
export const bucketKeyEnabledSchema = z.boolean();
export const bypassGovernanceRetentionSchema = z.boolean();
export const confirmRemoveSelfBucketAccessSchema = z.boolean();
export const deleteMarkerSchema = z.boolean();
export const enableRequestProgressSchema = z.boolean();
export const expiredObjectDeleteMarkerSchema = z.boolean();
export const fetchOwnerSchema = z.boolean();
export const isEnabledSchema = z.boolean();
export const isLatestSchema = z.boolean();
export const isPublicSchema = z.boolean();
export const isRestoreInProgressSchema = z.boolean();
export const isTruncatedSchema = z.boolean();
export const objectLockEnabledForBucketSchema = z.boolean();
export const quietSchema = z.boolean();
export const settingSchema = z.boolean();
export const skipValidationSchema = z.boolean();
export enum AnalyticsS3ExportFileFormat {
  CSV = "CSV",
}
export const analyticsS3ExportFileFormatSchema = z.enum(AnalyticsS3ExportFileFormat);
export enum ArchiveStatus {
  ARCHIVE_ACCESS = "ARCHIVE_ACCESS",
  DEEP_ARCHIVE_ACCESS = "DEEP_ARCHIVE_ACCESS",
}
export const archiveStatusSchema = z.enum(ArchiveStatus);
export enum BucketAbacStatus {
  Enabled = "Enabled",
  Disabled = "Disabled",
}
export const bucketAbacStatusSchema = z.enum(BucketAbacStatus);
export enum BucketAccelerateStatus {
  Enabled = "Enabled",
  Suspended = "Suspended",
}
export const bucketAccelerateStatusSchema = z.enum(BucketAccelerateStatus);
export enum BucketCannedACL {
  private = "private",
  public_read = "public-read",
  public_read_write = "public-read-write",
  authenticated_read = "authenticated-read",
}
export const bucketCannedAclSchema = z.enum(BucketCannedACL);
export enum BucketLocationConstraint {
  af_south_1 = "af-south-1",
  ap_east_1 = "ap-east-1",
  ap_northeast_1 = "ap-northeast-1",
  ap_northeast_2 = "ap-northeast-2",
  ap_northeast_3 = "ap-northeast-3",
  ap_south_1 = "ap-south-1",
  ap_south_2 = "ap-south-2",
  ap_southeast_1 = "ap-southeast-1",
  ap_southeast_2 = "ap-southeast-2",
  ap_southeast_3 = "ap-southeast-3",
  ap_southeast_4 = "ap-southeast-4",
  ap_southeast_5 = "ap-southeast-5",
  ca_central_1 = "ca-central-1",
  cn_north_1 = "cn-north-1",
  cn_northwest_1 = "cn-northwest-1",
  EU = "EU",
  eu_central_1 = "eu-central-1",
  eu_central_2 = "eu-central-2",
  eu_north_1 = "eu-north-1",
  eu_south_1 = "eu-south-1",
  eu_south_2 = "eu-south-2",
  eu_west_1 = "eu-west-1",
  eu_west_2 = "eu-west-2",
  eu_west_3 = "eu-west-3",
  il_central_1 = "il-central-1",
  me_central_1 = "me-central-1",
  me_south_1 = "me-south-1",
  sa_east_1 = "sa-east-1",
  us_east_2 = "us-east-2",
  us_gov_east_1 = "us-gov-east-1",
  us_gov_west_1 = "us-gov-west-1",
  us_west_1 = "us-west-1",
  us_west_2 = "us-west-2",
}
export const bucketLocationConstraintSchema = z.enum(BucketLocationConstraint);
export enum BucketLogsPermission {
  FULL_CONTROL = "FULL_CONTROL",
  READ = "READ",
  WRITE = "WRITE",
}
export const bucketLogsPermissionSchema = z.enum(BucketLogsPermission);
export enum BucketType {
  Directory = "Directory",
}
export const bucketTypeSchema = z.enum(BucketType);
export enum BucketVersioningStatus {
  Enabled = "Enabled",
  Suspended = "Suspended",
}
export const bucketVersioningStatusSchema = z.enum(BucketVersioningStatus);
export enum ChecksumAlgorithm {
  CRC32 = "CRC32",
  CRC32C = "CRC32C",
  SHA1 = "SHA1",
  SHA256 = "SHA256",
  CRC64NVME = "CRC64NVME",
}
export const checksumAlgorithmSchema = z.enum(ChecksumAlgorithm);
export enum ChecksumMode {
  ENABLED = "ENABLED",
}
export const checksumModeSchema = z.enum(ChecksumMode);
export enum ChecksumType {
  COMPOSITE = "COMPOSITE",
  FULL_OBJECT = "FULL_OBJECT",
}
export const checksumTypeSchema = z.enum(ChecksumType);
export enum CompressionType {
  NONE = "NONE",
  GZIP = "GZIP",
  BZIP2 = "BZIP2",
}
export const compressionTypeSchema = z.enum(CompressionType);
export enum DataRedundancy {
  SingleAvailabilityZone = "SingleAvailabilityZone",
  SingleLocalZone = "SingleLocalZone",
}
export const dataRedundancySchema = z.enum(DataRedundancy);
export enum DeleteMarkerReplicationStatus {
  Enabled = "Enabled",
  Disabled = "Disabled",
}
export const deleteMarkerReplicationStatusSchema = z.enum(DeleteMarkerReplicationStatus);
/**
 * <p>Encoding type used by Amazon S3 to encode the <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html">object keys</a> in the response. Responses are
 *       encoded only in UTF-8. An object key can contain any Unicode character. However, the XML 1.0 parser
 *       can't parse certain characters, such as characters with an ASCII value from 0 to 10. For characters that
 *       aren't supported in XML 1.0, you can add this parameter to request that Amazon S3 encode the keys in the
 *       response. For more information about characters to avoid in object key names, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-guidelines">Object key
 *         naming guidelines</a>.</p>
 *          <note>
 *             <p>When using the URL encoding type, non-ASCII characters that are used in an object's key name will
 *         be percent-encoded according to UTF-8 code values. For example, the object
 *           <code>test_file(3).png</code> will appear as <code>test_file%283%29.png</code>.</p>
 *          </note>
 */
export enum EncodingType {
  url = "url",
}
export const encodingTypeSchema = z.enum(EncodingType);
export enum EncryptionType {
  NONE = "NONE",
  SSE_C = "SSE-C",
}
export const encryptionTypeSchema = z.enum(EncryptionType);
/** <p>The bucket event for which to send notifications.</p> */
export enum Event {
  s3_ReducedRedundancyLostObject = "s3:ReducedRedundancyLostObject",
  s3_ObjectCreated_ = "s3:ObjectCreated:*",
  s3_ObjectCreated_Put = "s3:ObjectCreated:Put",
  s3_ObjectCreated_Post = "s3:ObjectCreated:Post",
  s3_ObjectCreated_Copy = "s3:ObjectCreated:Copy",
  s3_ObjectCreated_CompleteMultipartUpload = "s3:ObjectCreated:CompleteMultipartUpload",
  s3_ObjectRemoved_ = "s3:ObjectRemoved:*",
  s3_ObjectRemoved_Delete = "s3:ObjectRemoved:Delete",
  s3_ObjectRemoved_DeleteMarkerCreated = "s3:ObjectRemoved:DeleteMarkerCreated",
  s3_ObjectRestore_ = "s3:ObjectRestore:*",
  s3_ObjectRestore_Post = "s3:ObjectRestore:Post",
  s3_ObjectRestore_Completed = "s3:ObjectRestore:Completed",
  s3_Replication_ = "s3:Replication:*",
  s3_Replication_OperationFailedReplication = "s3:Replication:OperationFailedReplication",
  s3_Replication_OperationNotTracked = "s3:Replication:OperationNotTracked",
  s3_Replication_OperationMissedThreshold = "s3:Replication:OperationMissedThreshold",
  s3_Replication_OperationReplicatedAfterThreshold = "s3:Replication:OperationReplicatedAfterThreshold",
  s3_ObjectRestore_Delete = "s3:ObjectRestore:Delete",
  s3_LifecycleTransition = "s3:LifecycleTransition",
  s3_IntelligentTiering = "s3:IntelligentTiering",
  s3_ObjectAcl_Put = "s3:ObjectAcl:Put",
  s3_LifecycleExpiration_ = "s3:LifecycleExpiration:*",
  s3_LifecycleExpiration_Delete = "s3:LifecycleExpiration:Delete",
  s3_LifecycleExpiration_DeleteMarkerCreated = "s3:LifecycleExpiration:DeleteMarkerCreated",
  s3_ObjectTagging_ = "s3:ObjectTagging:*",
  s3_ObjectTagging_Put = "s3:ObjectTagging:Put",
  s3_ObjectTagging_Delete = "s3:ObjectTagging:Delete",
}
export const eventSchema = z.enum(Event);
export enum ExistingObjectReplicationStatus {
  Enabled = "Enabled",
  Disabled = "Disabled",
}
export const existingObjectReplicationStatusSchema = z.enum(ExistingObjectReplicationStatus);
export enum ExpirationState {
  ENABLED = "ENABLED",
  DISABLED = "DISABLED",
}
export const expirationStateSchema = z.enum(ExpirationState);
export enum ExpirationStatus {
  Enabled = "Enabled",
  Disabled = "Disabled",
}
export const expirationStatusSchema = z.enum(ExpirationStatus);
export enum ExpressionType {
  SQL = "SQL",
}
export const expressionTypeSchema = z.enum(ExpressionType);
export enum FileHeaderInfo {
  USE = "USE",
  IGNORE = "IGNORE",
  NONE = "NONE",
}
export const fileHeaderInfoSchema = z.enum(FileHeaderInfo);
export enum FilterRuleName {
  prefix = "prefix",
  suffix = "suffix",
}
export const filterRuleNameSchema = z.enum(FilterRuleName);
export enum IntelligentTieringAccessTier {
  ARCHIVE_ACCESS = "ARCHIVE_ACCESS",
  DEEP_ARCHIVE_ACCESS = "DEEP_ARCHIVE_ACCESS",
}
export const intelligentTieringAccessTierSchema = z.enum(IntelligentTieringAccessTier);
export enum IntelligentTieringStatus {
  Enabled = "Enabled",
  Disabled = "Disabled",
}
export const intelligentTieringStatusSchema = z.enum(IntelligentTieringStatus);
export enum InventoryConfigurationState {
  ENABLED = "ENABLED",
  DISABLED = "DISABLED",
}
export const inventoryConfigurationStateSchema = z.enum(InventoryConfigurationState);
export enum InventoryFormat {
  CSV = "CSV",
  ORC = "ORC",
  Parquet = "Parquet",
}
export const inventoryFormatSchema = z.enum(InventoryFormat);
export enum InventoryFrequency {
  Daily = "Daily",
  Weekly = "Weekly",
}
export const inventoryFrequencySchema = z.enum(InventoryFrequency);
export enum InventoryIncludedObjectVersions {
  All = "All",
  Current = "Current",
}
export const inventoryIncludedObjectVersionsSchema = z.enum(InventoryIncludedObjectVersions);
export enum InventoryOptionalField {
  Size = "Size",
  LastModifiedDate = "LastModifiedDate",
  StorageClass = "StorageClass",
  ETag = "ETag",
  IsMultipartUploaded = "IsMultipartUploaded",
  ReplicationStatus = "ReplicationStatus",
  EncryptionStatus = "EncryptionStatus",
  ObjectLockRetainUntilDate = "ObjectLockRetainUntilDate",
  ObjectLockMode = "ObjectLockMode",
  ObjectLockLegalHoldStatus = "ObjectLockLegalHoldStatus",
  IntelligentTieringAccessTier = "IntelligentTieringAccessTier",
  BucketKeyStatus = "BucketKeyStatus",
  ChecksumAlgorithm = "ChecksumAlgorithm",
  ObjectAccessControlList = "ObjectAccessControlList",
  ObjectOwner = "ObjectOwner",
  LifecycleExpirationDate = "LifecycleExpirationDate",
}
export const inventoryOptionalFieldSchema = z.enum(InventoryOptionalField);
export enum JSONType {
  DOCUMENT = "DOCUMENT",
  LINES = "LINES",
}
export const jsonTypeSchema = z.enum(JSONType);
export enum LocationType {
  AvailabilityZone = "AvailabilityZone",
  LocalZone = "LocalZone",
}
export const locationTypeSchema = z.enum(LocationType);
export enum MFADelete {
  Enabled = "Enabled",
  Disabled = "Disabled",
}
export const mfaDeleteSchema = z.enum(MFADelete);
export enum MFADeleteStatus {
  Enabled = "Enabled",
  Disabled = "Disabled",
}
export const mfaDeleteStatusSchema = z.enum(MFADeleteStatus);
export enum MetadataDirective {
  COPY = "COPY",
  REPLACE = "REPLACE",
}
export const metadataDirectiveSchema = z.enum(MetadataDirective);
export enum MetricsStatus {
  Enabled = "Enabled",
  Disabled = "Disabled",
}
export const metricsStatusSchema = z.enum(MetricsStatus);
export enum ObjectAttributes {
  ETAG = "ETag",
  CHECKSUM = "Checksum",
  OBJECT_PARTS = "ObjectParts",
  STORAGE_CLASS = "StorageClass",
  OBJECT_SIZE = "ObjectSize",
}
export const objectAttributesSchema = z.enum(ObjectAttributes);
export enum ObjectCannedACL {
  private = "private",
  public_read = "public-read",
  public_read_write = "public-read-write",
  authenticated_read = "authenticated-read",
  aws_exec_read = "aws-exec-read",
  bucket_owner_read = "bucket-owner-read",
  bucket_owner_full_control = "bucket-owner-full-control",
}
export const objectCannedAclSchema = z.enum(ObjectCannedACL);
export enum ObjectLockEnabled {
  Enabled = "Enabled",
}
export const objectLockEnabledSchema = z.enum(ObjectLockEnabled);
export enum ObjectLockLegalHoldStatus {
  ON = "ON",
  OFF = "OFF",
}
export const objectLockLegalHoldStatusSchema = z.enum(ObjectLockLegalHoldStatus);
export enum ObjectLockMode {
  GOVERNANCE = "GOVERNANCE",
  COMPLIANCE = "COMPLIANCE",
}
export const objectLockModeSchema = z.enum(ObjectLockMode);
export enum ObjectLockRetentionMode {
  GOVERNANCE = "GOVERNANCE",
  COMPLIANCE = "COMPLIANCE",
}
export const objectLockRetentionModeSchema = z.enum(ObjectLockRetentionMode);
/**
 * <p>The container element for object ownership for a bucket's ownership controls.</p>
 *          <p>
 *             <code>BucketOwnerPreferred</code> - Objects uploaded to the bucket change ownership to the bucket
 *       owner if the objects are uploaded with the <code>bucket-owner-full-control</code> canned ACL.</p>
 *          <p>
 *             <code>ObjectWriter</code> - The uploading account will own the object if the object is uploaded with
 *       the <code>bucket-owner-full-control</code> canned ACL.</p>
 *          <p>
 *             <code>BucketOwnerEnforced</code> - Access control lists (ACLs) are disabled and no longer affect
 *       permissions. The bucket owner automatically owns and has full control over every object in the bucket.
 *       The bucket only accepts PUT requests that don't specify an ACL or specify bucket owner full control ACLs
 *       (such as the predefined <code>bucket-owner-full-control</code> canned ACL or a custom ACL in XML format
 *       that grants the same permissions).</p>
 *          <p>By default, <code>ObjectOwnership</code> is set to <code>BucketOwnerEnforced</code> and ACLs are
 *       disabled. We recommend keeping ACLs disabled, except in uncommon use cases where you must control access
 *       for each object individually. For more information about S3 Object Ownership, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/about-object-ownership.html">Controlling
 *         ownership of objects and disabling ACLs for your bucket</a> in the
 *         <i>Amazon S3 User Guide</i>. </p>
 *          <note>
 *             <p>This functionality is not supported for directory buckets. Directory buckets use the bucket owner enforced setting for S3 Object Ownership.</p>
 *          </note>
 */
export enum ObjectOwnership {
  BucketOwnerPreferred = "BucketOwnerPreferred",
  ObjectWriter = "ObjectWriter",
  BucketOwnerEnforced = "BucketOwnerEnforced",
}
export const objectOwnershipSchema = z.enum(ObjectOwnership);
export enum ObjectStorageClass {
  STANDARD = "STANDARD",
  REDUCED_REDUNDANCY = "REDUCED_REDUNDANCY",
  GLACIER = "GLACIER",
  STANDARD_IA = "STANDARD_IA",
  ONEZONE_IA = "ONEZONE_IA",
  INTELLIGENT_TIERING = "INTELLIGENT_TIERING",
  DEEP_ARCHIVE = "DEEP_ARCHIVE",
  OUTPOSTS = "OUTPOSTS",
  GLACIER_IR = "GLACIER_IR",
  SNOW = "SNOW",
  EXPRESS_ONEZONE = "EXPRESS_ONEZONE",
  FSX_OPENZFS = "FSX_OPENZFS",
  FSX_ONTAP = "FSX_ONTAP",
}
export const objectStorageClassSchema = z.enum(ObjectStorageClass);
export enum ObjectVersionStorageClass {
  STANDARD = "STANDARD",
}
export const objectVersionStorageClassSchema = z.enum(ObjectVersionStorageClass);
export enum OptionalObjectAttributes {
  RESTORE_STATUS = "RestoreStatus",
}
export const optionalObjectAttributesSchema = z.enum(OptionalObjectAttributes);
export enum OwnerOverride {
  Destination = "Destination",
}
export const ownerOverrideSchema = z.enum(OwnerOverride);
export enum PartitionDateSource {
  EventTime = "EventTime",
  DeliveryTime = "DeliveryTime",
}
export const partitionDateSourceSchema = z.enum(PartitionDateSource);
export enum Payer {
  Requester = "Requester",
  BucketOwner = "BucketOwner",
}
export const payerSchema = z.enum(Payer);
export enum Permission {
  FULL_CONTROL = "FULL_CONTROL",
  WRITE = "WRITE",
  WRITE_ACP = "WRITE_ACP",
  READ = "READ",
  READ_ACP = "READ_ACP",
}
export const permissionSchema = z.enum(Permission);
export enum Protocol {
  http = "http",
  https = "https",
}
export const protocolSchema = z.enum(Protocol);
export enum QuoteFields {
  ALWAYS = "ALWAYS",
  ASNEEDED = "ASNEEDED",
}
export const quoteFieldsSchema = z.enum(QuoteFields);
export enum ReplicaModificationsStatus {
  Enabled = "Enabled",
  Disabled = "Disabled",
}
export const replicaModificationsStatusSchema = z.enum(ReplicaModificationsStatus);
export enum ReplicationRuleStatus {
  Enabled = "Enabled",
  Disabled = "Disabled",
}
export const replicationRuleStatusSchema = z.enum(ReplicationRuleStatus);
export enum ReplicationStatus {
  COMPLETE = "COMPLETE",
  PENDING = "PENDING",
  FAILED = "FAILED",
  REPLICA = "REPLICA",
  COMPLETED = "COMPLETED",
}
export const replicationStatusSchema = z.enum(ReplicationStatus);
export enum ReplicationTimeStatus {
  Enabled = "Enabled",
  Disabled = "Disabled",
}
export const replicationTimeStatusSchema = z.enum(ReplicationTimeStatus);
/**
 * <p>If present, indicates that the requester was successfully charged for the request. For more
 *       information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/RequesterPaysBuckets.html">Using Requester Pays buckets for storage transfers and usage</a> in the <i>Amazon Simple
 *         Storage Service user guide</i>.</p>
 *          <note>
 *             <p>This functionality is not supported for directory buckets.</p>
 *          </note>
 */
export enum RequestCharged {
  requester = "requester",
}
export const requestChargedSchema = z.enum(RequestCharged);
/**
 * <p>Confirms that the requester knows that they will be charged for the request. Bucket owners need not
 *       specify this parameter in their requests. If either the source or destination S3 bucket has Requester
 *       Pays enabled, the requester will pay for the corresponding charges. For information about
 *       downloading objects from Requester Pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html">Downloading Objects in Requester Pays
 *         Buckets</a> in the <i>Amazon S3 User Guide</i>.</p>
 *          <note>
 *             <p>This functionality is not supported for directory buckets.</p>
 *          </note>
 */
export enum RequestPayer {
  requester = "requester",
}
export const requestPayerSchema = z.enum(RequestPayer);
export enum RestoreRequestType {
  SELECT = "SELECT",
}
export const restoreRequestTypeSchema = z.enum(RestoreRequestType);
export enum S3TablesBucketType {
  aws = "aws",
  customer = "customer",
}
export const s3TablesBucketTypeSchema = z.enum(S3TablesBucketType);
export enum ServerSideEncryption {
  AES256 = "AES256",
  aws_fsx = "aws:fsx",
  aws_kms = "aws:kms",
  aws_kms_dsse = "aws:kms:dsse",
}
export const serverSideEncryptionSchema = z.enum(ServerSideEncryption);
export enum SessionMode {
  ReadOnly = "ReadOnly",
  ReadWrite = "ReadWrite",
}
export const sessionModeSchema = z.enum(SessionMode);
export enum SseKmsEncryptedObjectsStatus {
  Enabled = "Enabled",
  Disabled = "Disabled",
}
export const sseKmsEncryptedObjectsStatusSchema = z.enum(SseKmsEncryptedObjectsStatus);
export enum StorageClass {
  STANDARD = "STANDARD",
  REDUCED_REDUNDANCY = "REDUCED_REDUNDANCY",
  STANDARD_IA = "STANDARD_IA",
  ONEZONE_IA = "ONEZONE_IA",
  INTELLIGENT_TIERING = "INTELLIGENT_TIERING",
  GLACIER = "GLACIER",
  DEEP_ARCHIVE = "DEEP_ARCHIVE",
  OUTPOSTS = "OUTPOSTS",
  GLACIER_IR = "GLACIER_IR",
  SNOW = "SNOW",
  EXPRESS_ONEZONE = "EXPRESS_ONEZONE",
  FSX_OPENZFS = "FSX_OPENZFS",
  FSX_ONTAP = "FSX_ONTAP",
}
export const storageClassSchema = z.enum(StorageClass);
export enum StorageClassAnalysisSchemaVersion {
  V_1 = "V_1",
}
export const storageClassAnalysisSchemaVersionSchema = z.enum(StorageClassAnalysisSchemaVersion);
export enum TableSseAlgorithm {
  aws_kms = "aws:kms",
  AES256 = "AES256",
}
export const tableSseAlgorithmSchema = z.enum(TableSseAlgorithm);
export enum TaggingDirective {
  COPY = "COPY",
  REPLACE = "REPLACE",
}
export const taggingDirectiveSchema = z.enum(TaggingDirective);
export enum Tier {
  Standard = "Standard",
  Bulk = "Bulk",
  Expedited = "Expedited",
}
export const tierSchema = z.enum(Tier);
export enum TransitionDefaultMinimumObjectSize {
  varies_by_storage_class = "varies_by_storage_class",
  all_storage_classes_128K = "all_storage_classes_128K",
}
export const transitionDefaultMinimumObjectSizeSchema = z.enum(TransitionDefaultMinimumObjectSize);
export enum TransitionStorageClass {
  GLACIER = "GLACIER",
  STANDARD_IA = "STANDARD_IA",
  ONEZONE_IA = "ONEZONE_IA",
  INTELLIGENT_TIERING = "INTELLIGENT_TIERING",
  DEEP_ARCHIVE = "DEEP_ARCHIVE",
  GLACIER_IR = "GLACIER_IR",
}
export const transitionStorageClassSchema = z.enum(TransitionStorageClass);
export enum Type {
  CanonicalUser = "CanonicalUser",
  AmazonCustomerByEmail = "AmazonCustomerByEmail",
  Group = "Group",
}
export const typeSchema = z.enum(Type);
export const daysSchema = z.number();
export const daysAfterInitiationSchema = z.number();
export const getObjectResponseStatusCodeSchema = z.number();
export const intelligentTieringDaysSchema = z.number();
export const keyCountSchema = z.number();
export const maxAgeSecondsSchema = z.number();
export const maxBucketsSchema = z.number().min(1).max(10000);
export const maxDirectoryBucketsSchema = z.number().min(0).max(1000);
export const maxKeysSchema = z.number();
export const maxPartsSchema = z.number();
export const maxUploadsSchema = z.number();
export const minutesSchema = z.number();
export const missingMetaSchema = z.number();
export const partNumberSchema = z.number();
export const partsCountSchema = z.number();
export const prioritySchema = z.number();
export const recordExpirationDaysSchema = z.number();
export const tagCountSchema = z.number();
export const versionCountSchema = z.number();
export const yearsSchema = z.number();
export const bytesProcessedSchema = z.bigint();
export const bytesReturnedSchema = z.bigint();
export const bytesScannedSchema = z.bigint();
export const contentLengthSchema = z.bigint();
export const endSchema = z.bigint();
export const ifMatchSizeSchema = z.bigint();
export const mpuObjectSizeSchema = z.bigint();
export const objectSizeSchema = z.bigint();
export const objectSizeGreaterThanBytesSchema = z.bigint();
export const objectSizeLessThanBytesSchema = z.bigint();
export const sizeSchema = z.bigint();
export const startSchema = z.bigint();
export const writeOffsetBytesSchema = z.bigint();
export const abortRuleIdSchema = z.string();
export const acceptRangesSchema = z.string();
export const accessKeyIdValueSchema = z.string();
export const accessPointArnSchema = z.string();
export const accountIdSchema = z.string();
export const allowedHeaderSchema = z.string();
export const allowedMethodSchema = z.string();
export const allowedOriginSchema = z.string();
export const analyticsIdSchema = z.string();
export const bucketLocationNameSchema = z.string();
export const bucketNameSchema = z.string();
export const bucketRegionSchema = z.string();
export const cacheControlSchema = z.string();
export const checksumCrc32Schema = z.string();
export const checksumCrc32CSchema = z.string();
export const checksumCrc64NvmeSchema = z.string();
export const checksumSha1Schema = z.string();
export const checksumSha256Schema = z.string();
export const clientTokenSchema = z.string();
export const codeSchema = z.string();
export const commentsSchema = z.string();
export const contentDispositionSchema = z.string();
export const contentEncodingSchema = z.string();
export const contentLanguageSchema = z.string();
export const contentMd5Schema = z.string();
export const contentRangeSchema = z.string();
export const contentTypeSchema = z.string();
export const copySourceSchema = z.string().regex(new RegExp("^\\/?.+\\/.+$"));
export const copySourceIfMatchSchema = z.string();
export const copySourceIfNoneMatchSchema = z.string();
export const copySourceRangeSchema = z.string();
export const copySourceSseCustomerAlgorithmSchema = z.string();
export const copySourceSseCustomerKeySchema = z.string();
export const copySourceSseCustomerKeyMd5Schema = z.string();
export const copySourceVersionIdSchema = z.string();
export const deleteMarkerVersionIdSchema = z.string();
export const delimiterSchema = z.string();
export const descriptionSchema = z.string();
export const directoryBucketTokenSchema = z.string().min(0).max(1024);
export const displayNameSchema = z.string();
export const eTagSchema = z.string();
export const emailAddressSchema = z.string();
export const errorCodeSchema = z.string();
export const errorMessageSchema = z.string();
export const expirationSchema = z.string();
export const expiresSchema = z.string();
export const exposeHeaderSchema = z.string();
export const expressionSchema = z.string();
export const fieldDelimiterSchema = z.string();
export const filterRuleValueSchema = z.string();
export const grantFullControlSchema = z.string();
export const grantReadSchema = z.string();
export const grantReadAcpSchema = z.string();
export const grantWriteSchema = z.string();
export const grantWriteAcpSchema = z.string();
export const hostNameSchema = z.string();
export const httpErrorCodeReturnedEqualsSchema = z.string();
export const httpRedirectCodeSchema = z.string();
export const idSchema = z.string();
export const ifMatchSchema = z.string();
export const ifNoneMatchSchema = z.string();
export const intelligentTieringIdSchema = z.string();
export const inventoryIdSchema = z.string();
export const kmsContextSchema = z.string();
export const keyMarkerSchema = z.string();
export const keyPrefixEqualsSchema = z.string();
export const kmsKeyArnSchema = z.string();
export const lambdaFunctionArnSchema = z.string();
export const locationSchema = z.string();
export const locationNameAsStringSchema = z.string();
export const locationPrefixSchema = z.string();
export const mfaSchema = z.string();
export const markerSchema = z.string();
export const messageSchema = z.string();
export const metadataKeySchema = z.string();
export const metadataTableStatusSchema = z.string();
export const metadataValueSchema = z.string();
export const metricsIdSchema = z.string();
export const multipartUploadIdSchema = z.string();
export const nextKeyMarkerSchema = z.string();
export const nextMarkerSchema = z.string();
export const nextPartNumberMarkerSchema = z.string();
export const nextTokenSchema = z.string();
export const nextUploadIdMarkerSchema = z.string();
export const nextVersionIdMarkerSchema = z.string();
export const nonEmptyKmsKeyArnStringSchema = z.string().min(20).max(2048).regex(
  new RegExp("^arn:aws[a-zA-Z0-9-]*:kms:[a-z0-9-]+:[0-9]{12}:key/[a-zA-Z0-9-]+$"),
);
/**
 * <p>An optional unique identifier for configurations in a notification configuration. If you don't
 *       provide one, Amazon S3 will assign an ID.</p>
 */
export const notificationIdSchema = z.string();
export const objectKeySchema = z.string().min(1);
export const objectLockTokenSchema = z.string();
export const objectVersionIdSchema = z.string();
export const partNumberMarkerSchema = z.string();
export const policySchema = z.string();
export const prefixSchema = z.string();
export const queueArnSchema = z.string();
export const quoteCharacterSchema = z.string();
export const quoteEscapeCharacterSchema = z.string();
export const rangeSchema = z.string();
export const recordDelimiterSchema = z.string();
export const regionSchema = z.string().min(0).max(20);
export const renameSourceSchema = z.string().regex(new RegExp("^\\/?.+\\/.+$"));
export const renameSourceIfMatchSchema = z.string();
export const renameSourceIfNoneMatchSchema = z.string();
export const replaceKeyPrefixWithSchema = z.string();
export const replaceKeyWithSchema = z.string();
export const replicaKmsKeyIdSchema = z.string();
export const requestRouteSchema = z.string();
export const requestTokenSchema = z.string();
export const responseCacheControlSchema = z.string();
export const responseContentDispositionSchema = z.string();
export const responseContentEncodingSchema = z.string();
export const responseContentLanguageSchema = z.string();
export const responseContentTypeSchema = z.string();
export const restoreSchema = z.string();
export const restoreOutputPathSchema = z.string();
export const roleSchema = z.string();
export const s3RegionalOrS3ExpressBucketArnStringSchema = z.string().min(1).max(128).regex(
  new RegExp("^arn:[^:]+:(s3|s3express):"),
);
export const s3TablesArnSchema = z.string();
export const s3TablesBucketArnSchema = z.string();
export const s3TablesNameSchema = z.string();
export const s3TablesNamespaceSchema = z.string();
export const sseCustomerAlgorithmSchema = z.string();
export const sseCustomerKeySchema = z.string();
export const sseCustomerKeyMd5Schema = z.string();
export const ssekmsEncryptionContextSchema = z.string();
export const ssekmsKeyIdSchema = z.string();
export const sessionCredentialValueSchema = z.string();
export const startAfterSchema = z.string();
export const suffixSchema = z.string();
export const taggingHeaderSchema = z.string();
export const targetBucketSchema = z.string();
export const targetPrefixSchema = z.string();
export const tokenSchema = z.string();
export const topicArnSchema = z.string();
export const uriSchema = z.string();
export const uploadIdMarkerSchema = z.string();
export const valueSchema = z.string();
export const versionIdMarkerSchema = z.string();
export const websiteRedirectLocationSchema = z.string();
export const abortDateSchema = z.string().regex(
  new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:\\d{2})$"),
).refine((value) => {
  const truncated = value.replace(/\.(\d{3})\d+(?=Z|[+-]\d{2}:\d{2}$)/, ".$1");
  return !Number.isNaN(new Date(truncated).getTime());
}, "Invalid RFC3339 date-time timestamp").transform((value) => {
  const truncated = value.replace(/\.(\d{3})\d+(?=Z|[+-]\d{2}:\d{2}$)/, ".$1");
  return new Date(truncated).toISOString();
});
export const copySourceIfModifiedSinceSchema = z.string().regex(
  new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:\\d{2})$"),
).refine((value) => {
  const truncated = value.replace(/\.(\d{3})\d+(?=Z|[+-]\d{2}:\d{2}$)/, ".$1");
  return !Number.isNaN(new Date(truncated).getTime());
}, "Invalid RFC3339 date-time timestamp").transform((value) => {
  const truncated = value.replace(/\.(\d{3})\d+(?=Z|[+-]\d{2}:\d{2}$)/, ".$1");
  return new Date(truncated).toISOString();
});
export const copySourceIfUnmodifiedSinceSchema = z.string().regex(
  new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:\\d{2})$"),
).refine((value) => {
  const truncated = value.replace(/\.(\d{3})\d+(?=Z|[+-]\d{2}:\d{2}$)/, ".$1");
  return !Number.isNaN(new Date(truncated).getTime());
}, "Invalid RFC3339 date-time timestamp").transform((value) => {
  const truncated = value.replace(/\.(\d{3})\d+(?=Z|[+-]\d{2}:\d{2}$)/, ".$1");
  return new Date(truncated).toISOString();
});
export const creationDateSchema = z.string().regex(
  new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:\\d{2})$"),
).refine((value) => {
  const truncated = value.replace(/\.(\d{3})\d+(?=Z|[+-]\d{2}:\d{2}$)/, ".$1");
  return !Number.isNaN(new Date(truncated).getTime());
}, "Invalid RFC3339 date-time timestamp").transform((value) => {
  const truncated = value.replace(/\.(\d{3})\d+(?=Z|[+-]\d{2}:\d{2}$)/, ".$1");
  return new Date(truncated).toISOString();
});
export const dateSchema = z.string().regex(
  new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:\\d{2})$"),
).refine((value) => {
  const truncated = value.replace(/\.(\d{3})\d+(?=Z|[+-]\d{2}:\d{2}$)/, ".$1");
  return !Number.isNaN(new Date(truncated).getTime());
}, "Invalid RFC3339 date-time timestamp").transform((value) => {
  const truncated = value.replace(/\.(\d{3})\d+(?=Z|[+-]\d{2}:\d{2}$)/, ".$1");
  return new Date(truncated).toISOString();
});
export const ifMatchInitiatedTimeSchema = z.string().regex(
  new RegExp(
    "^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), \\d{2} (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \\d{4} \\d{2}:\\d{2}:\\d{2} GMT$",
  ),
).refine((value) => {
  const parsed = new Date(value);
  return !Number.isNaN(parsed.getTime()) && parsed.toUTCString() === value;
}, "Invalid IMF-fixdate timestamp");
export const ifMatchLastModifiedTimeSchema = z.string().regex(
  new RegExp(
    "^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), \\d{2} (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \\d{4} \\d{2}:\\d{2}:\\d{2} GMT$",
  ),
).refine((value) => {
  const parsed = new Date(value);
  return !Number.isNaN(parsed.getTime()) && parsed.toUTCString() === value;
}, "Invalid IMF-fixdate timestamp");
export const ifModifiedSinceSchema = z.string().regex(
  new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:\\d{2})$"),
).refine((value) => {
  const truncated = value.replace(/\.(\d{3})\d+(?=Z|[+-]\d{2}:\d{2}$)/, ".$1");
  return !Number.isNaN(new Date(truncated).getTime());
}, "Invalid RFC3339 date-time timestamp").transform((value) => {
  const truncated = value.replace(/\.(\d{3})\d+(?=Z|[+-]\d{2}:\d{2}$)/, ".$1");
  return new Date(truncated).toISOString();
});
export const ifUnmodifiedSinceSchema = z.string().regex(
  new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:\\d{2})$"),
).refine((value) => {
  const truncated = value.replace(/\.(\d{3})\d+(?=Z|[+-]\d{2}:\d{2}$)/, ".$1");
  return !Number.isNaN(new Date(truncated).getTime());
}, "Invalid RFC3339 date-time timestamp").transform((value) => {
  const truncated = value.replace(/\.(\d{3})\d+(?=Z|[+-]\d{2}:\d{2}$)/, ".$1");
  return new Date(truncated).toISOString();
});
export const initiatedSchema = z.string().regex(
  new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:\\d{2})$"),
).refine((value) => {
  const truncated = value.replace(/\.(\d{3})\d+(?=Z|[+-]\d{2}:\d{2}$)/, ".$1");
  return !Number.isNaN(new Date(truncated).getTime());
}, "Invalid RFC3339 date-time timestamp").transform((value) => {
  const truncated = value.replace(/\.(\d{3})\d+(?=Z|[+-]\d{2}:\d{2}$)/, ".$1");
  return new Date(truncated).toISOString();
});
export const lastModifiedSchema = z.string().regex(
  new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:\\d{2})$"),
).refine((value) => {
  const truncated = value.replace(/\.(\d{3})\d+(?=Z|[+-]\d{2}:\d{2}$)/, ".$1");
  return !Number.isNaN(new Date(truncated).getTime());
}, "Invalid RFC3339 date-time timestamp").transform((value) => {
  const truncated = value.replace(/\.(\d{3})\d+(?=Z|[+-]\d{2}:\d{2}$)/, ".$1");
  return new Date(truncated).toISOString();
});
export const lastModifiedTimeSchema = z.string().regex(
  new RegExp(
    "^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), \\d{2} (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \\d{4} \\d{2}:\\d{2}:\\d{2} GMT$",
  ),
).refine((value) => {
  const parsed = new Date(value);
  return !Number.isNaN(parsed.getTime()) && parsed.toUTCString() === value;
}, "Invalid IMF-fixdate timestamp");
export const objectLockRetainUntilDateSchema = z.string().regex(
  new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:\\d{2})$"),
).refine((value) => {
  const truncated = value.replace(/\.(\d{3})\d+(?=Z|[+-]\d{2}:\d{2}$)/, ".$1");
  return !Number.isNaN(new Date(truncated).getTime());
}, "Invalid RFC3339 date-time timestamp").transform((value) => {
  const truncated = value.replace(/\.(\d{3})\d+(?=Z|[+-]\d{2}:\d{2}$)/, ".$1");
  return new Date(truncated).toISOString();
});
export const renameSourceIfModifiedSinceSchema = z.string().regex(
  new RegExp(
    "^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), \\d{2} (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \\d{4} \\d{2}:\\d{2}:\\d{2} GMT$",
  ),
).refine((value) => {
  const parsed = new Date(value);
  return !Number.isNaN(parsed.getTime()) && parsed.toUTCString() === value;
}, "Invalid IMF-fixdate timestamp");
export const renameSourceIfUnmodifiedSinceSchema = z.string().regex(
  new RegExp(
    "^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), \\d{2} (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \\d{4} \\d{2}:\\d{2}:\\d{2} GMT$",
  ),
).refine((value) => {
  const parsed = new Date(value);
  return !Number.isNaN(parsed.getTime()) && parsed.toUTCString() === value;
}, "Invalid IMF-fixdate timestamp");
export const responseExpiresSchema = z.string().regex(
  new RegExp(
    "^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), \\d{2} (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \\d{4} \\d{2}:\\d{2}:\\d{2} GMT$",
  ),
).refine((value) => {
  const parsed = new Date(value);
  return !Number.isNaN(parsed.getTime()) && parsed.toUTCString() === value;
}, "Invalid IMF-fixdate timestamp");
export const restoreExpiryDateSchema = z.string().regex(
  new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:\\d{2})$"),
).refine((value) => {
  const truncated = value.replace(/\.(\d{3})\d+(?=Z|[+-]\d{2}:\d{2}$)/, ".$1");
  return !Number.isNaN(new Date(truncated).getTime());
}, "Invalid RFC3339 date-time timestamp").transform((value) => {
  const truncated = value.replace(/\.(\d{3})\d+(?=Z|[+-]\d{2}:\d{2}$)/, ".$1");
  return new Date(truncated).toISOString();
});
export const sessionExpirationSchema = z.string().regex(
  new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:\\d{2})$"),
).refine((value) => {
  const truncated = value.replace(/\.(\d{3})\d+(?=Z|[+-]\d{2}:\d{2}$)/, ".$1");
  return !Number.isNaN(new Date(truncated).getTime());
}, "Invalid RFC3339 date-time timestamp").transform((value) => {
  const truncated = value.replace(/\.(\d{3})\d+(?=Z|[+-]\d{2}:\d{2}$)/, ".$1");
  return new Date(truncated).toISOString();
});
export const allowedHeadersSchema = z.array(allowedHeaderSchema);
export const allowedMethodsSchema = z.array(allowedMethodSchema);
export const allowedOriginsSchema = z.array(allowedOriginSchema);
// TODO: list member target com.amazonaws.s3#AnalyticsConfiguration is not generated yet.
export const analyticsConfigurationListSchema = z.array(z.unknown());
// TODO: smithy.api#xmlName ("Bucket") on list member is not mapped to zod.
// TODO: list member target com.amazonaws.s3#Bucket is not generated yet.
export const bucketsSchema = z.array(z.unknown());
// TODO: list member target com.amazonaws.s3#CORSRule is not generated yet.
export const corsRulesSchema = z.array(z.unknown());
export const checksumAlgorithmListSchema = z.array(checksumAlgorithmSchema);
// TODO: list member target com.amazonaws.s3#CommonPrefix is not generated yet.
export const commonPrefixListSchema = z.array(z.unknown());
// TODO: list member target com.amazonaws.s3#CompletedPart is not generated yet.
export const completedPartListSchema = z.array(z.unknown());
// TODO: list member target com.amazonaws.s3#DeleteMarkerEntry is not generated yet.
export const deleteMarkersSchema = z.array(z.unknown());
// TODO: list member target com.amazonaws.s3#DeletedObject is not generated yet.
export const deletedObjectsSchema = z.array(z.unknown());
// TODO: smithy.api#xmlName ("EncryptionType") on list member is not mapped to zod.
export const encryptionTypeListSchema = z.array(encryptionTypeSchema);
// TODO: list member target com.amazonaws.s3#Error is not generated yet.
export const errorsSchema = z.array(z.unknown());
export const eventListSchema = z.array(eventSchema);
export const exposeHeadersSchema = z.array(exposeHeaderSchema);
// TODO: list member target com.amazonaws.s3#FilterRule is not generated yet.
/** <p>A list of containers for the key-value pair that defines the criteria for the filter rule.</p> */
export const filterRuleListSchema = z.array(z.unknown());
// TODO: smithy.api#xmlName ("Grant") on list member is not mapped to zod.
// TODO: list member target com.amazonaws.s3#Grant is not generated yet.
export const grantsSchema = z.array(z.unknown());
// TODO: list member target com.amazonaws.s3#IntelligentTieringConfiguration is not generated yet.
export const intelligentTieringConfigurationListSchema = z.array(z.unknown());
// TODO: list member target com.amazonaws.s3#InventoryConfiguration is not generated yet.
export const inventoryConfigurationListSchema = z.array(z.unknown());
// TODO: smithy.api#xmlName ("Field") on list member is not mapped to zod.
export const inventoryOptionalFieldsSchema = z.array(inventoryOptionalFieldSchema);
// TODO: list member target com.amazonaws.s3#LambdaFunctionConfiguration is not generated yet.
export const lambdaFunctionConfigurationListSchema = z.array(z.unknown());
// TODO: list member target com.amazonaws.s3#LifecycleRule is not generated yet.
export const lifecycleRulesSchema = z.array(z.unknown());
// TODO: list member target com.amazonaws.s3#MetricsConfiguration is not generated yet.
export const metricsConfigurationListSchema = z.array(z.unknown());
// TODO: list member target com.amazonaws.s3#MultipartUpload is not generated yet.
export const multipartUploadListSchema = z.array(z.unknown());
// TODO: list member target com.amazonaws.s3#NoncurrentVersionTransition is not generated yet.
export const noncurrentVersionTransitionListSchema = z.array(z.unknown());
export const objectAttributesListSchema = z.array(objectAttributesSchema);
// TODO: list member target com.amazonaws.s3#ObjectIdentifier is not generated yet.
export const objectIdentifierListSchema = z.array(z.unknown());
// TODO: list member target com.amazonaws.s3#Object is not generated yet.
export const objectListSchema = z.array(z.unknown());
// TODO: list member target com.amazonaws.s3#ObjectVersion is not generated yet.
export const objectVersionListSchema = z.array(z.unknown());
export const optionalObjectAttributesListSchema = z.array(optionalObjectAttributesSchema);
// TODO: list member target com.amazonaws.s3#OwnershipControlsRule is not generated yet.
export const ownershipControlsRulesSchema = z.array(z.unknown());
// TODO: list member target com.amazonaws.s3#Part is not generated yet.
export const partsSchema = z.array(z.unknown());
// TODO: list member target com.amazonaws.s3#ObjectPart is not generated yet.
export const partsListSchema = z.array(z.unknown());
// TODO: list member target com.amazonaws.s3#QueueConfiguration is not generated yet.
export const queueConfigurationListSchema = z.array(z.unknown());
// TODO: list member target com.amazonaws.s3#ReplicationRule is not generated yet.
export const replicationRulesSchema = z.array(z.unknown());
// TODO: smithy.api#xmlName ("RoutingRule") on list member is not mapped to zod.
// TODO: list member target com.amazonaws.s3#RoutingRule is not generated yet.
export const routingRulesSchema = z.array(z.unknown());
// TODO: list member target com.amazonaws.s3#ServerSideEncryptionRule is not generated yet.
export const serverSideEncryptionRulesSchema = z.array(z.unknown());
// TODO: smithy.api#xmlName ("Tag") on list member is not mapped to zod.
// TODO: list member target com.amazonaws.s3#Tag is not generated yet.
export const tagSetSchema = z.array(z.unknown());
// TODO: smithy.api#xmlName ("Grant") on list member is not mapped to zod.
// TODO: list member target com.amazonaws.s3#TargetGrant is not generated yet.
export const targetGrantsSchema = z.array(z.unknown());
// TODO: list member target com.amazonaws.s3#Tiering is not generated yet.
export const tieringListSchema = z.array(z.unknown());
// TODO: list member target com.amazonaws.s3#TopicConfiguration is not generated yet.
export const topicConfigurationListSchema = z.array(z.unknown());
// TODO: list member target com.amazonaws.s3#Transition is not generated yet.
export const transitionListSchema = z.array(z.unknown());
// TODO: smithy.api#xmlName ("MetadataEntry") on list member is not mapped to zod.
// TODO: list member target com.amazonaws.s3#MetadataEntry is not generated yet.
export const userMetadataSchema = z.array(z.unknown());
