// Auto-generated by smithy-gen. Do not edit.
import { z } from "zod/v4";
import { ChecksumAlgorithm } from "./aws.protocols.enums.js";

/**
 * ```xml
 * Contains HTTP protocol configuration for HTTP-based protocols.
 * ```
 */
export const httpConfigurationSchema = z.object({
  /**
   * ```xml
   * The priority ordered list of supported HTTP protocol versions.
   * ```
   */
  http: z.array(z.string()).optional(),
  /**
   * ```xml
   * The priority ordered list of supported HTTP protocol versions that
   * are required when using event streams with the service. If not set,
   * this value defaults to the value of the `http` member. Any entry in
   * `eventStreamHttp` MUST also appear in `http`.
   * ```
   */
  eventStreamHttp: z.array(z.string()).optional(),
});
export type HttpConfiguration = z.infer<typeof httpConfigurationSchema>;

/**
 * ```xml
 * An RPC-based protocol that sends JSON payloads. This protocol does not use
 * HTTP binding traits.
 * ```
 */
export const awsJson10Schema = z.object({});
export type AwsJson10 = z.infer<typeof awsJson10Schema>;

/**
 * ```xml
 * An RPC-based protocol that sends JSON payloads. This protocol does not use
 * HTTP binding traits.
 * ```
 */
export const awsJson11Schema = z.object({});
export type AwsJson11 = z.infer<typeof awsJson11Schema>;

/**
 * ```xml
 * An RPC-based protocol that sends 'POST' requests in the body as
 * `x-www-form-urlencoded` strings and responses in XML documents. This
 * protocol does not use HTTP binding traits.
 * ```
 */
export const awsQuerySchema = z.object({});
export type AwsQuery = z.infer<typeof awsQuerySchema>;

/**
 * ```xml
 * Enable backward compatibility when migrating from awsQuery to the awsJson
 * protocol or Smithy RPC v2 CBOR.
 * ```
 */
export const awsQueryCompatibleSchema = z.object({});
export type AwsQueryCompatible = z.infer<typeof awsQueryCompatibleSchema>;

/**
 * ```xml
 * Provides the value in the 'Code' distinguishing field and HTTP response
 * code for an operation error.
 * ```
 */
export const awsQueryErrorSchema = z.object({
  /**
   * ```xml
   * The value used to distinguish this error shape during serialization.
   * ```
   */
  code: z.string(),
  /**
   * ```xml
   * The HTTP response code used on a response containing this error shape.
   * ```
   */
  httpResponseCode: z.number(),
});
export type AwsQueryError = z.infer<typeof awsQueryErrorSchema>;

/**
 * ```xml
 * An RPC-based protocol that sends 'POST' requests in the body as Amazon EC2
 * formatted `x-www-form-urlencoded` strings and responses in XML documents.
 * This protocol does not use HTTP binding traits.
 * ```
 */
export const ec2QuerySchema = z.object({});
export type Ec2Query = z.infer<typeof ec2QuerySchema>;

/**
 * ```xml
 * Indicates that an operation supports checksum validation.
 * ```
 */
export const httpChecksumSchema = z.object({
  /**
   * ```xml
   * Defines a top-level operation input member that is used to configure
   * request checksum behavior.
   * ```
   */
  requestAlgorithmMember: z.string().optional(),
  /**
   * ```xml
   * Indicates an operation requires a checksum in its HTTP request.
   * ```
   */
  requestChecksumRequired: z.boolean().optional(),
  /**
   * ```xml
   * Defines a top-level operation input member used to opt-in to response
   * checksum validation.
   * ```
   */
  requestValidationModeMember: z.string().optional(),
  /**
   * ```xml
   * Defines the checksum algorithms clients should look for when performing
   * HTTP response checksum validation.
   * ```
   */
  responseAlgorithms: z.array(z.enum(ChecksumAlgorithm)).min(1).superRefine((items, refinementContext) => {
    const seen = new Map<string, number>();
    for (let index = 0; index < items.length; index += 1) {
      const serialized = JSON.stringify(items[index]);
      const key = serialized === undefined ? "__undefined__" : serialized;
      const previousIndex = seen.get(key);
      if (previousIndex !== undefined) {
        refinementContext.addIssue({ code: "custom", message: "Duplicate items are not allowed.", path: [index] });
        return;
      }
      seen.set(key, index);
    }
  }).optional(),
});
export type HttpChecksum = z.infer<typeof httpChecksumSchema>;

/**
 * ```xml
 * A RESTful protocol that sends JSON in structured payloads.
 * ```
 */
export const restJson1Schema = z.object({});
export type RestJson1 = z.infer<typeof restJson1Schema>;

/**
 * ```xml
 * A RESTful protocol that sends XML in structured payloads.
 * ```
 */
export const restXmlSchema = z.object({
  /**
   * ```xml
   * Disables the serialization wrapping of error properties in an 'Error'
   * XML element.
   * ```
   */
  noErrorWrapping: z.boolean().optional(),
});
export type RestXml = z.infer<typeof restXmlSchema>;
